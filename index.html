<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Latest News Podcasts: CBC, BBC, Al Jazeera, ABC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0c0d; --card:#15171a; --text:#e9eef2; --muted:#aab4be; --accent:#79b8ff; }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:1rem 1.25rem;border-bottom:1px solid #222}
    h1{margin:0;font-size:1.1rem;letter-spacing:.3px}
    .wrap{max-width:920px;margin:0 auto;padding:1rem}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:1rem}
    .card{background:var(--card);border:1px solid #222;border-radius:14px;padding:1rem;display:flex;flex-direction:column;gap:.75rem}
    .source{font-size:.8rem;color:var(--muted)}
    .title{font-weight:600;line-height:1.2;font-size:14pt;margin-bottom:0.5rem}
    .meta{font-size:.85rem;color:var(--muted)}
    
    /* Podcast image styles */
    .card-content{display:flex;gap:1rem}
    .podcast-image{width:80px;height:80px;border-radius:8px;object-fit:cover;flex-shrink:0;background:var(--card);border:1px solid #333}
    .card-info{flex:1;display:flex;flex-direction:column;gap:0.5rem}
    
    /* Expandable summary */
    .episode-summary{margin-top:0.75rem}
    .summary-toggle{background:none;border:none;color:var(--accent);cursor:pointer;font-size:0.8rem;padding:0;text-decoration:underline}
    .summary-toggle:hover{color:var(--text)}
    .summary-content{margin-top:0.5rem;font-size:0.85rem;line-height:1.4;color:var(--muted);display:none}
    .summary-content.expanded{display:block}
    .summary-meta{display:flex;gap:1rem;font-size:0.75rem;color:var(--muted);margin-top:0.5rem;flex-wrap:wrap}
    .row{display:flex;justify-content:space-between;gap:.5rem;align-items:center}
    .btn{appearance:none;border:1px solid #2a2f36;background:#0e1116;color:var(--text);padding:.45rem .7rem;border-radius:8px;font-size:.9rem;cursor:pointer}
    .btn:hover{border-color:#39424d}
    audio{width:100%}
    .error{color:#ff9aa2;font-size:.9rem}
    footer{color:var(--muted);font-size:.8rem;text-align:center;margin:1.5rem 0}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    
    /* UI Controls */
    .controls{display:flex;gap:0.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center}
    .control-btn{padding:0.5rem 1rem;border:1px solid #333;background:#1a1a1a;color:var(--text);border-radius:6px;cursor:pointer;font-size:0.9rem}
    .control-btn:hover{background:#2a2a2a;border-color:#444}
    
    /* Global audio controls */
    .global-audio-controls{display:flex;gap:1rem;align-items:center;padding:0.75rem 1rem;background:var(--card);border:1px solid #333;border-radius:8px;margin-bottom:1rem;flex-wrap:wrap}
    .global-control-group{display:flex;align-items:center;gap:0.5rem;font-size:0.9rem}
    .global-control-group label{color:var(--muted);font-weight:500}
    .global-select{background:var(--card);border:1px solid #444;color:var(--text);padding:0.4rem 0.6rem;border-radius:4px;font-size:0.85rem}
    .global-status{color:var(--accent);font-weight:500;font-size:0.9rem}
    
    /* Language sections */
    #english-section, #french-section{margin-bottom:2rem}
    #french-section{display:none}
    .section-title{font-size:1.2rem;margin-bottom:1rem;color:var(--accent);border-bottom:1px solid #333;padding-bottom:0.5rem}
    
    /* Light theme */
    body.light-theme{--bg:#ffffff; --card:#f8f9fa; --text:#24292e; --muted:#586069; --accent:#0366d6}
    body.light-theme .control-btn{background:#f6f8fa;border-color:#d0d7de;color:var(--text)}
    body.light-theme .control-btn:hover{background:#f3f4f6;border-color:#afb8c1}
    body.light-theme .section-title{border-color:#d0d7de}
    body.light-theme .podcast-image{border-color:#d0d7de}
    body.light-theme .global-audio-controls{background:#f6f8fa;border-color:#d0d7de}
    body.light-theme .global-select{background:#ffffff;border-color:#d0d7de}

    /* Loading animation - minimal since content appears immediately */
    .loading{text-align:center;padding:1rem;font-size:0.9rem;color:var(--muted)}
    .spinner{display:inline-block;width:20px;height:20px;border:2px solid #333;border-radius:50%;border-top-color:var(--accent);animation:spin 1s ease-in-out infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    
    /* Fade animations */
    .fade-out{opacity:0;transition:opacity 0.5s ease}
    .fade-in{opacity:1;transition:opacity 0.5s ease}
    #content{opacity:0}
  </style>
</head>
<body>
  <header><h1>üéôÔ∏è Latest News Podcasts</h1></header>
  <div class="wrap">
    <div class="controls">
      <button id="theme-toggle" class="control-btn">üåô Dark</button>
      <button id="language-toggle" class="control-btn">üá´üá∑ Fran√ßais</button>
      <button id="refresh-button" class="control-btn">üîÑ Refresh</button>
    </div>
    
    <div class="global-audio-controls">
      <div class="global-control-group">
        <label>üéß Global Speed:</label>
        <select id="global-speed" class="global-select">
          <option value="0.5">0.5x</option>
          <option value="0.75">0.75x</option>
          <option value="1" selected>1x</option>
          <option value="1.25">1.25x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
      </div>
      <div class="global-control-group">
        <label>üò¥ Sleep Timer:</label>
        <select id="global-sleep" class="global-select">
          <option value="0">Off</option>
          <option value="15">15 min</option>
          <option value="30">30 min</option>
          <option value="45">45 min</option>
          <option value="60">1 hour</option>
        </select>
      </div>
      <div id="global-sleep-status" class="global-status"></div>
    </div>
    
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <p>Loading latest podcasts...</p>
    </div>
    
    <div id="content" style="display:none">
      <div id="english-section">
        <h2 class="section-title">üá¨üáß English Podcasts (Latest First)</h2>
        <div id="cards-english" class="grid" aria-live="polite"></div>
      </div>
      
      <div id="french-section">
        <h2 class="section-title">üá´üá∑ Podcasts Fran√ßais (Plus R√©cents)</h2>
        <div id="cards-french" class="grid" aria-live="polite"></div>
      </div>
      
      <div id="errors"></div>
      <footer>Feeds load fresh on page open. Times shown in your local timezone.</footer>
    </div>
  </div>

<script>
(function(){
  console.log("RSS script starting...");
  
  // Multiple CORS proxy options - updated with more reliable proxies
  const CORS_PROXIES = [
    "https://corsproxy.io/?",
    "https://api.codetabs.com/v1/proxy?quest=",
    "https://cors-anywhere.herokuapp.com/"
  ];

  // CBC podcast feeds with labels for individual display
  const CBC_FEEDS = [
    { label: "CBC World Report", url: "https://www.cbc.ca/podcasting/includes/wr.xml" },
    { label: "CBC The House", url: "https://www.cbc.ca/podcasting/includes/thehouse.xml" },
    { label: "CBC The World This Hour", url: "https://www.cbc.ca/podcasting/includes/hourlynews.xml" },
    { label: "CBC Your World Tonight", url: "https://www.cbc.ca/podcasting/includes/w6.xml" },
    { label: "CBC At Issue", url: "https://www.cbc.ca/podcasting/includes/atissue.xml" }
  ];

  // English podcast feeds (ordered by reliability - fastest first)
  const FEEDS = [
    { key:"bbc-podcast",  label:"BBC Global News Podcast",     url:"https://podcasts.files.bbci.co.uk/p02nq0gn.rss" },
    { key:"abc",          label:"ABC (Australia) AM",          url:"https://www.abc.net.au/feeds/8486620/podcast.xml" },
    { key:"aje",          label:"Al Jazeera Updates",          url:"https://omnycontent.com/d/playlist/9c074afa-3313-47e8-b802-a9f900789975/63048eda-2427-408a-b47c-ad5001293fca/6677d422-fd43-4aaa-be74-ad5001293fd8/podcast.rss" },
    { key:"npr-news",     label:"NPR News Now",               url:"https://feeds.npr.org/500005/podcast.xml" },
    { key:"democracy-now", label:"Democracy Now!",            url:"https://www.democracynow.org/podcast.xml" },
  ];

  // French podcast feeds (verified working)
  const FRENCH_FEEDS = [
    { key:"news-slow-fr",    label:"News in Slow French",           url:"https://nsf.libsyn.com/rss" },
    { key:"france-inter",    label:"France Inter - L'invit√© 8h20",  url:"https://radiofrance-podcast.net/podcast09/rss_10239.xml" },
  ];

  const cardsEnglishEl = document.getElementById("cards-english");
  const cardsFrenchEl = document.getElementById("cards-french");
  const errEl = document.getElementById("errors");
  const loadingEl = document.getElementById("loading");
  const contentEl = document.getElementById("content");

  function esc(s){ 
    return s == null ? "" : (""+s).replace(/[&<>"']/g, function(c) {
      const escMap = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"};
      return escMap[c];
    }); 
  }

  function parsePubDate(d){
    // Try native Date; many podcast feeds are RFC822/RFC1123 or ISO8601
    const dt = new Date(d);
    return isNaN(dt) ? null : dt;
  }

  function hoursAgoIfToday(dt){
    if (!dt) return "";
    const now = new Date();
    if (dt.toDateString() === now.toDateString()){
      const hrs = Math.max(0, Math.round((now - dt)/36e5));
      return hrs + " hour" + (hrs===1?"":"s") + " ago";
    }
    return dt.toLocaleString(undefined, { dateStyle:"medium", timeStyle:"short" });
  }

  function firstItemFromRSS(xmlText){
    const doc = new DOMParser().parseFromString(xmlText, "application/xml");
    if (doc.querySelector("parsererror")) throw new Error("Invalid XML or blocked by CORS");

    // RSS 2.0
    let item = doc.querySelector("channel > item");
    // Atom
    if (!item) item = doc.querySelector("entry");
    if (!item) throw new Error("No items in feed");

    const title = (item.querySelector("title")?.textContent || "").trim();
    const pubRaw = (item.querySelector("pubDate, updated")?.textContent || "").trim();
    const pubDate = parsePubDate(pubRaw);

    // Extract episode metadata
    const description = (item.querySelector("description")?.textContent || 
                        item.querySelector("itunes\\:summary")?.textContent || 
                        item.querySelector("summary")?.textContent || "").trim();
    
    const duration = (item.querySelector("itunes\\:duration")?.textContent || "").trim();
    const author = (item.querySelector("itunes\\:author")?.textContent || 
                   item.querySelector("author")?.textContent || "").trim();

    // Extract image - try multiple sources
    let imageUrl = null;
    
    // Try episode-specific image first
    imageUrl = item.querySelector("itunes\\:image")?.getAttribute("href");
    if (!imageUrl) imageUrl = item.querySelector("media\\:thumbnail")?.getAttribute("url");
    if (!imageUrl) imageUrl = item.querySelector("image url")?.textContent?.trim();
    
    // Fall back to podcast/channel image
    if (!imageUrl) {
      const channel = doc.querySelector("channel");
      if (channel) {
        imageUrl = channel.querySelector("itunes\\:image")?.getAttribute("href");
        if (!imageUrl) imageUrl = channel.querySelector("image url")?.textContent?.trim();
        if (!imageUrl) {
          const img = channel.querySelector("image");
          if (img) imageUrl = img.querySelector("url")?.textContent?.trim();
        }
      }
    }

    // Prefer <enclosure url="...">
    let audioUrl = item.querySelector("enclosure[url]")?.getAttribute("url");

    // media:content fallback
    if (!audioUrl){
      const m = item.querySelector("media\\:content[url], content[url]");
      if (m) audioUrl = m.getAttribute("url");
    }

    // CBC contentLink fallback (special case for CBC feeds)
    if (!audioUrl){
      const contentLink = item.querySelector("contentLink")?.textContent?.trim();
      if (contentLink && /\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(contentLink)) {
        audioUrl = contentLink;
      }
    }

    // GUID or link fallback if it looks like audio
    if (!audioUrl){
      const guid = item.querySelector("guid")?.textContent?.trim();
      const link = item.querySelector("link")?.textContent?.trim() || item.querySelector("link[href]")?.getAttribute("href");
      const pick = [guid, link].find(u => typeof u === "string" && /\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(u));
      if (pick) audioUrl = pick;
    }

    // PODCASTS ONLY: Reject items without audio content
    if (!audioUrl || !/\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(audioUrl)) {
      throw new Error("No audio content found - this appears to be an article feed, not a podcast");
    }

    return { title, pubDate, audioUrl, imageUrl, description, duration, author };
  }

  function renderCard({label, title, pubDate, audioUrl, imageUrl, description, duration, author}){
    const when = hoursAgoIfToday(pubDate);
    const el = document.createElement("div");
    el.className = "card";
    
    // Store raw timestamp for sorting (crucial for news ordering!)
    if (pubDate) {
      el.setAttribute('data-pubdate', pubDate.getTime());
    }
    
    // Generate unique ID for this card
    const cardId = 'card-' + Math.random().toString(36).substr(2, 9);
    
    // Clean up description (remove HTML tags and extra whitespace)
    const cleanDescription = description ? description.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim() : '';
    const hasDescription = cleanDescription && cleanDescription.length > 50;
    
    el.innerHTML = 
      '<div class="source">' + esc(label) + '</div>' +
      '<div class="card-content">' +
        (imageUrl ? '<img class="podcast-image" src="' + esc(imageUrl) + '" alt="Podcast image" onerror="this.style.display=\'none\'">' : '') +
        '<div class="card-info">' +
          '<div class="title">' + (esc(title) || "(untitled episode)") + '</div>' +
          '<div class="row">' +
            '<div class="meta">' + (when ? esc(when) : "") + '</div>' +
            '<button class="btn play-btn" type="button">Play</button>' +
          '</div>' +
          (hasDescription ? 
            '<div class="episode-summary">' +
              '<button class="summary-toggle" type="button">üìñ Show Details</button>' +
              '<div class="summary-content">' +
                '<div>' + esc(cleanDescription.substring(0, 500)) + (cleanDescription.length > 500 ? '...' : '') + '</div>' +
                '<div class="summary-meta">' +
                  (duration ? '<span>‚è±Ô∏è ' + esc(duration) + '</span>' : '') +
                  (author ? '<span>üë§ ' + esc(author) + '</span>' : '') +
                '</div>' +
              '</div>' +
            '</div>' : '') +
        '</div>' +
      '</div>' +
      '<audio preload="none" controls src="' + esc(audioUrl) + '" class="global-audio" id="audio-' + cardId + '"></audio>';
    
    const btn = el.querySelector(".play-btn");
    const audio = el.querySelector("audio");
    const summaryToggle = el.querySelector(".summary-toggle");
    const summaryContent = el.querySelector(".summary-content");
    
    // Play button functionality
    btn.addEventListener("click", function() { 
      // Pause all other audio elements
      document.querySelectorAll('audio').forEach(a => {
        if (a !== audio) a.pause();
      });
      
      audio.play(); 
      btn.disabled = true; 
      btn.textContent = "Playing";
      
      // Apply global speed setting
      const globalSpeed = document.getElementById('global-speed').value;
      audio.playbackRate = parseFloat(globalSpeed);
    });
    
    // Reset button when audio ends or pauses
    audio.addEventListener("ended", function() {
      btn.disabled = false;
      btn.textContent = "Play";
    });
    
    audio.addEventListener("pause", function() {
      btn.disabled = false;
      btn.textContent = "Play";
    });
    
    // Summary toggle functionality
    if (summaryToggle && summaryContent) {
      summaryToggle.addEventListener("click", function() {
        const isExpanded = summaryContent.classList.contains('expanded');
        summaryContent.classList.toggle('expanded');
        summaryToggle.textContent = isExpanded ? 'üìñ Show Details' : 'üìñ Hide Details';
      });
    }
    
    return el;
  }

  function noteError(label, err){
    console.error("Failed to load " + label + ":", err);
    const p = document.createElement("p");
    p.className = "error";
    p.textContent = "Failed to load " + label + ": " + (err.message || err);
    errEl.appendChild(p);
  }

  function debugLog(message, data) {
    // Only log important events to reduce console spam
    if (message.includes('‚úÖ') || message.includes('‚ùå') || message.includes('Progressive loading')) {
      console.log("üéôÔ∏è " + message, data || '');
    }
  }

  function infoLog(message) {
    console.log("üì° " + message);
  }

  async function fetchText(url){
    debugLog("Attempting to fetch: " + url);
    
    // Try direct access first with browser-like headers
    try {
      debugLog("Trying direct fetch with browser headers");
      const r = await fetch(url, { 
        mode:"cors", 
        cache:"no-store",
        signal: AbortSignal.timeout(10000),
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
          'Accept': 'application/rss+xml, application/xml, text/xml, */*',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1'
        }
      });
      if (!r.ok) throw new Error("Direct HTTP " + r.status);
      const text = await r.text();
      debugLog("‚úÖ Successfully fetched directly, length: " + text.length);
      return text;
    } catch(directError) {
      infoLog("Using CORS proxy for " + url.split('/')[2]);
      
      // Try each proxy in sequence
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        try {
          const proxy = CORS_PROXIES[i];
          const proxyUrl = proxy + encodeURIComponent(url);
          debugLog("Trying proxy " + (i+1) + ": " + proxy);
          
          const r = await fetch(proxyUrl, { 
            cache:"no-store",
            signal: AbortSignal.timeout(8000),
            headers: {
              'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
              'Accept': 'application/rss+xml, application/xml, text/xml, */*',
              'Accept-Language': 'en-US,en;q=0.9',
              'Referer': 'https://www.google.com/'
            }
          });
          
          if (!r.ok) throw new Error("HTTP " + r.status);
          const text = await r.text();
          debugLog("‚úÖ Success with proxy " + (i+1) + ", length: " + text.length);
          return text;
        } catch(proxyError) {
          // Only log failures for the first attempt to reduce console spam
          if (i === 0) debugLog("‚ùå Proxy " + (i+1) + " failed: " + (proxyError.name === 'TimeoutError' ? 'timeout' : proxyError.message));
          continue;
        }
      }
      
      throw new Error("All methods failed. Direct: " + directError.message + ". All " + CORS_PROXIES.length + " proxies also failed.");
    }
  }

  async function loadSingleFeed(label, url){
    try {
      debugLog("Loading single feed: " + label);
      const xml = await fetchText(url);
      const info = firstItemFromRSS(xml);
      debugLog("Parsed feed item:", { title: info.title, pubDate: info.pubDate, hasAudio: !!info.audioUrl });
      const card = renderCard({ 
        label: label, 
        title: info.title, 
        pubDate: info.pubDate, 
        audioUrl: info.audioUrl, 
        imageUrl: info.imageUrl,
        description: info.description,
        duration: info.duration,
        author: info.author
      });
      debugLog("Successfully created card for: " + label);
      return card;
    } catch(e) {
      noteError(label, e);
      return null;
    }
  }

  // CRITICAL: Sort podcast cards by publication date (newest first) for latest news
  function sortCardsByDate(container) {
    const cards = Array.from(container.children);
    
    cards.sort((cardA, cardB) => {
      // Use stored timestamp for reliable sorting
      const timestampA = parseInt(cardA.getAttribute('data-pubdate')) || 0;
      const timestampB = parseInt(cardB.getAttribute('data-pubdate')) || 0;
      
      // Sort newest first (descending order) - CRITICAL for news relevance
      return timestampB - timestampA;
    });
    
    // Re-append cards in sorted order
    container.innerHTML = '';
    cards.forEach(card => container.appendChild(card));
    
    debugLog("‚úÖ Sorted " + cards.length + " cards by date (newest first)");
  }

  // Load individual CBC feeds as separate cards
  async function loadAndDisplayCbcFeed(cbcFeed) {
    try {
      debugLog("Loading CBC feed: " + cbcFeed.label);
      const card = await loadSingleFeed(cbcFeed.label, cbcFeed.url);
      if (card) {
        cardsEnglishEl.appendChild(card);
        
        // Add fade-in animation
        card.style.opacity = '0';
        setTimeout(() => {
          card.style.transition = 'opacity 0.3s ease';
          card.style.opacity = '1';
        }, 10);
        
        debugLog("‚úÖ Displayed: " + cbcFeed.label);
      }
    } catch(e) {
      console.warn("‚ö†Ô∏è Could not load " + cbcFeed.label + " (CORS/network issue)");
    }
  }

  // Progressive loading function that shows cards as they load
  async function loadAndDisplayFeed(label, url, isEnglish = true) {
    try {
      debugLog("Loading feed: " + label);
      const card = await loadSingleFeed(label, url);
      if (card) {
        const targetContainer = isEnglish ? cardsEnglishEl : cardsFrenchEl;
        targetContainer.appendChild(card);
        
        // Add fade-in animation to new card
        card.style.opacity = '0';
        setTimeout(() => {
          card.style.transition = 'opacity 0.3s ease';
          card.style.opacity = '1';
        }, 10);
        
        debugLog("‚úÖ Displayed: " + label);
      }
    } catch(e) {
      console.warn("‚ö†Ô∏è Could not load " + label + " (CORS/network issue)");
    }
  }



  (async function init(){
    debugLog("Starting progressive RSS feed loading...");
    
    // Show content area immediately (no waiting for all feeds)
    loadingEl.style.display = "none";
    contentEl.style.display = "block";
    contentEl.style.opacity = "1";
    
    let totalLoaded = 0;
    const totalFeeds = FEEDS.length + FRENCH_FEEDS.length + CBC_FEEDS.length;
    
    // Load feeds in parallel for speed, but display each as it completes
    const loadPromises = [];
    
    // Start loading English feeds (fast ones first: BBC, ABC, Al Jazeera)
    FEEDS.forEach(f => {
      loadPromises.push(loadAndDisplayFeed(f.label, f.url, true));
    });
    
    // Start loading each CBC feed individually
    CBC_FEEDS.forEach(cbcFeed => {
      loadPromises.push(loadAndDisplayCbcFeed(cbcFeed));
    });
    
    // Start loading French feeds
    FRENCH_FEEDS.forEach(f => {
      loadPromises.push(loadAndDisplayFeed(f.label, f.url, false));
    });
    
    // Wait for all feeds to complete (but they're already displayed as they load)
    await Promise.allSettled(loadPromises);
    
    // CRITICAL: Sort all cards by publication date (newest first) - this is essential for news!
    sortCardsByDate(cardsEnglishEl);
    if (FRENCH_FEEDS.length > 0) {
      sortCardsByDate(cardsFrenchEl);
    }
    
    // Cache English content for language switching
    const englishCards = Array.from(cardsEnglishEl.children);
    const englishContent = englishCards.map(card => card.outerHTML);
    localStorage.setItem('cachedEnglishCards', JSON.stringify({
      timestamp: Date.now(),
      content: englishContent
    }));
    
    // Final summary
    const englishCount = cardsEnglishEl.children.length;
    const frenchCount = cardsFrenchEl.children.length;
    const totalCards = englishCount + frenchCount;
    const errorCount = errEl.children.length;
    
    console.log("üéôÔ∏è Loaded " + totalCards + " podcast" + (totalCards === 1 ? "" : "s") + " successfully!");
    
    if (totalCards === 0) {
      const p = document.createElement("p");
      p.className = "error";
      p.textContent = "No podcast feeds could be loaded. Check the browser console for detailed error messages.";
      errEl.appendChild(p);
    }
  })();

  // UI Controls functionality
  const themeToggle = document.getElementById('theme-toggle');
  const languageToggle = document.getElementById('language-toggle');
  const refreshButton = document.getElementById('refresh-button');
  const englishSection = document.getElementById('english-section');
  const frenchSection = document.getElementById('french-section');

  // Theme toggle
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    themeToggle.textContent = isLight ? 'üåô Dark' : '‚òÄÔ∏è Light';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
  });

  // Load saved theme
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'light') {
    document.body.classList.add('light-theme');
    themeToggle.textContent = 'üåô Dark';
  }

  // Language toggle with three states: English ‚Üí French ‚Üí Both ‚Üí English
  let languageState = localStorage.getItem('languageState') || 'english';
  
  function updateLanguageDisplay() {
    switch(languageState) {
      case 'english':
        englishSection.style.display = 'block';
        frenchSection.style.display = 'none';
        languageToggle.textContent = 'üá´üá∑ Fran√ßais';
        break;
      case 'french':
        englishSection.style.display = 'none';
        frenchSection.style.display = 'block';
        languageToggle.textContent = 'üåç Both';
        break;
      case 'both':
        englishSection.style.display = 'block';
        frenchSection.style.display = 'block';
        languageToggle.textContent = 'üá¨üáß English';
        
        // Restore English cards from cache if available and English section is empty
        if (cardsEnglishEl.children.length === 0) {
          const cached = localStorage.getItem('cachedEnglishCards');
          if (cached) {
            try {
              const { content, timestamp } = JSON.parse(cached);
              // Only use cache if it's less than 1 hour old
              if (Date.now() - timestamp < 3600000) {
                content.forEach(cardHtml => {
                  cardsEnglishEl.innerHTML += cardHtml;
                });
              }
            } catch(e) {
              console.warn('Failed to restore cached English cards:', e);
            }
          }
        }
        break;
    }
    localStorage.setItem('languageState', languageState);
  }

  languageToggle.addEventListener('click', () => {
    if (languageState === 'english') {
      languageState = 'french';
    } else if (languageState === 'french') {
      languageState = 'both';
    } else {
      languageState = 'english';
    }
    updateLanguageDisplay();
  });

  // Initialize language display
  updateLanguageDisplay();

  // Refresh button
  refreshButton.addEventListener('click', () => {
    location.reload();
  });

  // Global audio controls
  const globalSpeedSelect = document.getElementById('global-speed');
  const globalSleepSelect = document.getElementById('global-sleep');
  const globalSleepStatus = document.getElementById('global-sleep-status');
  
  let globalSleepTimer = null;
  let globalSleepInterval = null;
  let currentAudio = null;
  
  // Global speed control
  globalSpeedSelect.addEventListener('change', () => {
    const speed = parseFloat(globalSpeedSelect.value);
    // Apply to currently playing audio
    document.querySelectorAll('audio').forEach(audio => {
      if (!audio.paused) {
        audio.playbackRate = speed;
      }
    });
  });
  
  // Global sleep timer functionality
  function clearGlobalSleepTimer() {
    if (globalSleepTimer) clearTimeout(globalSleepTimer);
    if (globalSleepInterval) clearInterval(globalSleepInterval);
    globalSleepTimer = null;
    globalSleepInterval = null;
    globalSleepStatus.textContent = "";
    // Reset volume for all audio elements
    document.querySelectorAll('audio').forEach(audio => {
      audio.volume = 1;
    });
  }
  
  function startGlobalSleepTimer(minutes) {
    clearGlobalSleepTimer();
    
    if (minutes === 0) return;
    
    const totalMs = minutes * 60 * 1000;
    const fadeStartMs = totalMs - (2 * 60 * 1000); // Start fading 2 minutes before end
    let remainingTime = minutes * 60; // seconds
    
    // Update countdown every second
    globalSleepInterval = setInterval(() => {
      remainingTime--;
      const mins = Math.floor(remainingTime / 60);
      const secs = remainingTime % 60;
      globalSleepStatus.textContent = `Sleep: ${mins}:${secs.toString().padStart(2, '0')}`;
      
      // Start volume fade in last 2 minutes
      const elapsed = (minutes * 60) - remainingTime;
      if (elapsed * 1000 >= fadeStartMs) {
        const fadeProgress = (elapsed * 1000 - fadeStartMs) / (2 * 60 * 1000);
        const volume = Math.max(0, 1 - fadeProgress);
        // Apply fade to all audio elements
        document.querySelectorAll('audio').forEach(audio => {
          if (!audio.paused) {
            audio.volume = volume;
          }
        });
      }
      
      if (remainingTime <= 0) {
        // Pause all audio
        document.querySelectorAll('audio').forEach(audio => {
          audio.pause();
        });
        clearGlobalSleepTimer();
      }
    }, 1000);
    
    globalSleepStatus.textContent = `Sleep: ${minutes}:00`;
  }
  
  globalSleepSelect.addEventListener('change', () => {
    const minutes = parseInt(globalSleepSelect.value);
    startGlobalSleepTimer(minutes);
  });

  // Track currently playing audio for sleep timer
  document.addEventListener('play', (e) => {
    if (e.target.tagName === 'AUDIO') {
      currentAudio = e.target;
      // Apply current global speed to newly playing audio
      const globalSpeed = parseFloat(globalSpeedSelect.value);
      e.target.playbackRate = globalSpeed;
    }
  }, true);
})();
</script>
</body>
</html>
