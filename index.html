<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Latest News Podcasts: CBC, BBC, Al Jazeera, ABC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Latest news podcasts from BBC, CBC, NPR, Democracy Now, ABC Australia, Al Jazeera, and French sources with global audio controls, sleep timer, and accessibility features." />
  <style>
    /* WCAG AA compliant dark theme - 4.5:1 contrast ratio */
    :root { --bg:#0d1117; --card:#161b22; --text:#f0f6fc; --muted:#8b949e; --accent:#58a6ff; }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:1rem 1.25rem;border-bottom:1px solid #222}
    h1{margin:0;font-size:1.1rem;letter-spacing:.3px}
    .wrap{max-width:920px;margin:0 auto;padding:1rem}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:1rem}
    .card{background:var(--card);border:1px solid #222;border-radius:14px;padding:1rem;display:flex;flex-direction:column;gap:.75rem}
    .source{font-size:.8rem;color:var(--muted)}
    .title{font-weight:600;line-height:1.2;font-size:14pt;margin-bottom:0.5rem}
    .meta{font-size:.85rem;color:var(--muted)}
    .duration{color:var(--accent);font-weight:500}
    
    /* Podcast image styles */
    .card-content{display:flex;gap:1rem}
    .podcast-image{width:80px;height:80px;border-radius:8px;object-fit:cover;flex-shrink:0;background:var(--card);border:1px solid #333}
    .card-info{flex:1;display:flex;flex-direction:column;gap:0.5rem}
    
    /* Expandable summary */
    .episode-summary{margin-top:0.75rem}
    .summary-toggle{background:none;border:none;color:var(--accent);cursor:pointer;font-size:0.8rem;padding:0;text-decoration:underline}
    .summary-toggle:hover{color:var(--text)}
    .summary-content{margin-top:0.5rem;font-size:0.85rem;line-height:1.4;color:var(--muted);display:none}
    .summary-content.expanded{display:block}
    .summary-meta{display:flex;gap:1rem;font-size:0.75rem;color:var(--muted);margin-top:0.5rem;flex-wrap:wrap}
    .row{display:flex;justify-content:space-between;gap:.5rem;align-items:center}
    .btn{appearance:none;border:1px solid #2a2f36;background:#0e1116;color:var(--text);padding:.45rem .7rem;border-radius:8px;font-size:.9rem;cursor:pointer}
    .btn:hover{border-color:#39424d}
    audio{width:100%}
    .error{color:#ff9aa2;font-size:.9rem}
    footer{color:var(--muted);font-size:.8rem;text-align:center;margin:1.5rem 0}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    
    /* UI Controls */
    .controls{display:flex;gap:0.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center}
    .control-btn{padding:0.5rem 1rem;border:1px solid #333;background:#1a1a1a;color:var(--text);border-radius:6px;cursor:pointer;font-size:0.9rem}
    .control-btn:hover{background:#2a2a2a;border-color:#444}
    
    /* Global audio controls */
    .global-audio-controls{display:flex;gap:1rem;align-items:center;padding:0.75rem 1rem;background:var(--card);border:1px solid #333;border-radius:8px;margin-bottom:1rem;flex-wrap:wrap}
    .global-control-group{display:flex;align-items:center;gap:0.5rem;font-size:0.9rem}
    .global-control-group label{color:var(--muted);font-weight:500}
    .global-select{background:var(--card);border:1px solid #444;color:var(--text);padding:0.4rem 0.6rem;border-radius:4px;font-size:0.85rem}
    .global-status{color:var(--accent);font-weight:500;font-size:0.9rem}
    .cache-clear-btn{background:#e74c3c;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px;transition:background-color 0.2s}
    .cache-clear-btn:hover{background:#c0392b}
    .content-hidden{display:none}
    
    /* Screen reader only content */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    
    /* Skip link for keyboard users */
    .skip-link{position:absolute;top:-40px;left:6px;background:var(--accent);color:white;padding:8px;border-radius:4px;text-decoration:none;z-index:1000}
    .skip-link:focus{top:6px}
    
    /* Focus styles for better keyboard navigation */
    button:focus,select:focus,audio:focus{outline:2px solid var(--accent);outline-offset:2px}
    
    /* Ensure sufficient color contrast for interactive elements */
    .control-btn,.cache-clear-btn{min-height:44px;min-width:44px}
    
    /* Skip controls for audio */
    .skip-controls{display:flex;gap:0.5rem;margin-top:0.5rem;justify-content:center}
    .skip-btn{background:var(--card);border:1px solid #444;color:var(--text);padding:8px 12px;border-radius:4px;cursor:pointer;font-size:12px;display:flex;align-items:center;gap:0.25rem;transition:all 0.2s}
    .skip-btn:hover{background:var(--accent);color:white;border-color:var(--accent)}
    .skip-btn:disabled{opacity:0.5;cursor:not-allowed}
    body.light-theme .skip-btn{border-color:#d0d7de}
    body.light-theme .skip-btn:hover{background:var(--accent);color:white}
    .keyboard-shortcuts{font-size:11px;color:var(--muted);margin-top:0.5rem}
    
    /* Language sections */
    #english-section, #french-section{margin-bottom:2rem}
    #french-section{display:none}
    .section-title{font-size:1.2rem;margin-bottom:1rem;color:var(--accent);border-bottom:1px solid #333;padding-bottom:0.5rem}
    
    /* Light theme */
    /* WCAG AA compliant light theme - 4.5:1 contrast ratio */
    body.light-theme{--bg:#ffffff; --card:#f6f8fa; --text:#24292f; --muted:#656d76; --accent:#0969da}
    body.light-theme .control-btn{background:#f6f8fa;border-color:#d0d7de;color:var(--text)}
    body.light-theme .control-btn:hover{background:#f3f4f6;border-color:#afb8c1}
    body.light-theme .section-title{border-color:#d0d7de}
    body.light-theme .podcast-image{border-color:#d0d7de}
    body.light-theme .global-audio-controls{background:#f6f8fa;border-color:#d0d7de}
    body.light-theme .global-select{background:#ffffff;border-color:#d0d7de}

    /* Loading animation - minimal since content appears immediately */
    .loading{text-align:center;padding:1rem;font-size:0.9rem;color:var(--muted)}
    .spinner{display:inline-block;width:20px;height:20px;border:2px solid #333;border-radius:50%;border-top-color:var(--accent);animation:spin 1s ease-in-out infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    
    /* Fade animations */
    .fade-out{opacity:0;transition:opacity 0.5s ease}
    .fade-in{opacity:1;transition:opacity 0.5s ease}
    #content{opacity:0}
  </style>
</head>
<body>
  <a href="#content" class="skip-link">Skip to main content</a>
  <header role="banner">
    <h1>üéôÔ∏è Latest News Podcasts</h1>
  </header>
  <div class="wrap">
    <nav class="controls" role="navigation" aria-label="Page controls">
      <button id="theme-toggle" class="control-btn" aria-label="Toggle between light and dark theme">üåô Dark</button>
      <button id="language-toggle" class="control-btn" aria-label="Switch language or show both languages">üá´üá∑ Fran√ßais</button>
      <button id="refresh-button" class="control-btn">üîÑ Refresh</button>
    </div>
    
    <section class="global-audio-controls" role="region" aria-label="Global podcast controls">
      <h2 class="sr-only">Global Audio Controls</h2>
      <div class="global-control-group">
        <label for="global-speed">üéµ Speed:</label>
        <select id="global-speed" class="global-select" aria-label="Playback speed control">
          <option value="0.5">0.5x</option>
          <option value="0.75">0.75x</option>
          <option value="1" selected>1x</option>
          <option value="1.25">1.25x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
      </div>
      <div class="global-control-group">
        <label for="global-sleep">üò¥ Sleep Timer:</label>
        <select id="global-sleep" class="global-select" aria-label="Sleep timer duration">
          <option value="0">Off</option>
          <option value="5">5 min</option>
          <option value="10">10 min</option>
          <option value="15">15 min</option>
          <option value="20">20 min</option>
          <option value="25">25 min</option>
        </select>
      </div>
      <div class="global-control-group">
        <label for="duration-filter">‚è±Ô∏è Duration:</label>
        <select id="duration-filter" class="global-select" aria-label="Filter podcasts by duration">
          <option value="all">All</option>
          <option value="short">< 10 min</option>
          <option value="medium">10-30 min</option>
          <option value="long">> 30 min</option>
        </select>
      </div>
      <div id="global-sleep-status" class="global-status" aria-live="polite"></div>
      <div class="global-control-group">
        <button id="clear-cache-btn" class="cache-clear-btn" onclick="clearAllCache()" aria-label="Clear all cached data and refresh page">üßπ Clear Cache</button>
      </div>
      <div class="keyboard-shortcuts">
        ‚å®Ô∏è Shortcuts: ‚Üê Skip back 30s ‚Ä¢ ‚Üí Skip forward 30s ‚Ä¢ Space Play/Pause
      </div>
    </section>    <div id="loading" class="loading">
      <div class="spinner"></div>
      <p>Loading latest podcasts...</p>
    </div>
    
    <main id="content" class="content-hidden" role="main">
      <section id="english-section" role="region" aria-labelledby="english-heading">
        <h2 id="english-heading" class="section-title">üá¨üáß English Podcasts (Latest First)</h2>
        <div id="cards-english" class="grid" aria-live="polite" role="feed" aria-label="English podcast episodes"></div>
      </section>
      
      <section id="french-section" role="region" aria-labelledby="french-heading">
        <h2 id="french-heading" class="section-title">üá´üá∑ Podcasts Fran√ßais (Plus R√©cents)</h2>
        <div id="cards-french" class="grid" aria-live="polite" role="feed" aria-label="French podcast episodes"></div>
      </section>
      
      <div id="errors" role="alert" aria-live="assertive"></div>
      <footer role="contentinfo">
        <p>Feeds load fresh on page open. Times shown in your local timezone.</p>
      </footer>
    </main>
  </div>

<script>
(function(){
  console.log("RSS script starting...");
  
  // Multiple CORS proxy options - updated with more reliable proxies
  const CORS_PROXIES = [
    "https://corsproxy.io/?",
    "https://api.codetabs.com/v1/proxy?quest=",
    "https://cors-anywhere.herokuapp.com/"
  ];

  // CBC podcast feeds with labels for individual display
  const CBC_FEEDS = [
    { label: "CBC World Report", url: "https://www.cbc.ca/podcasting/includes/wr.xml" },
    { label: "CBC The House", url: "https://www.cbc.ca/podcasting/includes/thehouse.xml" },
    { label: "CBC The World This Hour", url: "https://www.cbc.ca/podcasting/includes/hourlynews.xml" },
    { label: "CBC Your World Tonight", url: "https://www.cbc.ca/podcasting/includes/w6.xml" },
    { label: "CBC At Issue", url: "https://www.cbc.ca/podcasting/includes/atissue.xml" }
  ];

  // English podcast feeds (ordered by reliability - fastest first)
  const FEEDS = [
    { key:"bbc-podcast",  label:"BBC Global News Podcast",     url:"https://podcasts.files.bbci.co.uk/p02nq0gn.rss" },
    { key:"bbc-newshour", label:"BBC World Service Newshour",  url:"https://podcasts.files.bbci.co.uk/p02nq0lx.rss" },
    { key:"abc",          label:"ABC (Australia) AM",          url:"https://www.abc.net.au/feeds/8486620/podcast.xml" },
    { key:"aje",          label:"Al Jazeera Updates",          url:"https://omnycontent.com/d/playlist/9c074afa-3313-47e8-b802-a9f900789975/63048eda-2427-408a-b47c-ad5001293fca/6677d422-fd43-4aaa-be74-ad5001293fd8/podcast.rss" },
    { key:"npr-news",     label:"NPR News Now",               url:"https://feeds.npr.org/500005/podcast.xml" },
    { key:"democracy-now", label:"Democracy Now!",            url:"https://www.democracynow.org/podcast.xml" },
    { key:"pbs-newshour", label:"PBS NewsHour Audio",         url:"https://feeds.npr.org/381444908/podcast.xml" },
    { key:"ap-news",      label:"AP News Minute",             url:"https://feeds.feedburner.com/APNewsMinute" },
    { key:"cnn-5things",  label:"CNN 5 Things",               url:"https://feeds.megaphone.fm/CNI9300048629" },
  ];

  // French podcast feeds (verified working)
  const FRENCH_FEEDS = [
    { key:"news-slow-fr",    label:"News in Slow French",           url:"https://nsf.libsyn.com/rss" },
    { key:"france-inter",    label:"France Inter - L'invit√© 8h20",  url:"https://radiofrance-podcast.net/podcast09/rss_10239.xml" },
    { key:"inner-french",    label:"InnerFrench Podcast",           url:"https://innerfrench.com/feed/" },
    { key:"rfi-afrique",     label:"RFI Afrique Matin",             url:"https://www.rfi.fr/fr/afrique/podcast.xml" },
    { key:"franceinfo",      label:"France Info Journal",           url:"https://radiofrance-podcast.net/podcast09/rss_18974.xml" },
  ];

  const cardsEnglishEl = document.getElementById("cards-english");
  const cardsFrenchEl = document.getElementById("cards-french");
  const errEl = document.getElementById("errors");
  const loadingEl = document.getElementById("loading");
  const contentEl = document.getElementById("content");

  // Global set to track seen episodes and prevent duplicates
  const seenEpisodes = new Set();
  let duplicatesSkipped = 0;

  // Cache version to invalidate old cached content when deduplication logic changes
  const CACHE_VERSION = "v2_with_deduplication";
  
  // Clear old cache if version doesn't match
  const currentCacheVersion = localStorage.getItem('cacheVersion');
  if (currentCacheVersion !== CACHE_VERSION) {
    localStorage.removeItem('cachedEnglishCards');
    localStorage.setItem('cacheVersion', CACHE_VERSION);
    console.log('üßπ Cleared old cache due to deduplication update');
  }

  // Function to manually clear all cache and reload (global scope)
  window.clearAllCache = function() {
    localStorage.removeItem('cachedEnglishCards');
    localStorage.removeItem('cacheVersion');
    seenEpisodes.clear();
    duplicatesSkipped = 0;
    console.log('üßπ All cache cleared manually');
    location.reload();
  };

  function esc(s){ 
    return s == null ? "" : (""+s).replace(/[&<>"']/g, function(c) {
      const escMap = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"};
      return escMap[c];
    }); 
  }

  function parsePubDate(d){
    // Try native Date; many podcast feeds are RFC822/RFC1123 or ISO8601
    const dt = new Date(d);
    return isNaN(dt) ? null : dt;
  }

  function hoursAgoIfToday(dt){
    if (!dt) return "";
    const now = new Date();
    if (dt.toDateString() === now.toDateString()){
      const hrs = Math.max(0, Math.round((now - dt)/36e5));
      return hrs + " hour" + (hrs===1?"":"s") + " ago";
    }
    return dt.toLocaleString(undefined, { dateStyle:"medium", timeStyle:"short" });
  }

  function formatDuration(duration) {
    if (!duration) return "";
    
    // Handle estimated durations with ~ prefix
    if (duration.startsWith('~')) {
      return duration; // Return as-is for estimated times
    }
    
    // Handle different duration formats from RSS feeds
    if (/^\d+$/.test(duration)) {
      // Seconds only (BBC format: "1944")
      const totalSeconds = parseInt(duration);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      } else {
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }
    } else if (/^\d{1,2}:\d{2}$/.test(duration)) {
      // MM:SS format (Democracy Now: "59:00")
      return duration;
    } else if (/^\d{1,2}:\d{2}:\d{2}$/.test(duration)) {
      // HH:MM:SS format (CBC: "00:10:08")
      // Remove leading zero hours if present
      return duration.replace(/^0+:/, '').replace(/^0(\d)/, '$1');
    }
    
    // Return as-is if format not recognized
    return duration;
  }

  function parseDurationToSeconds(duration) {
    if (!duration) return 0;
    
    // Handle estimated durations with ~ prefix
    let cleanDuration = duration;
    if (duration.startsWith('~')) {
      cleanDuration = duration.substring(1); // Remove the ~ prefix
    }
    
    // Handle different duration formats from RSS feeds
    if (/^\d+$/.test(cleanDuration)) {
      // Seconds only (BBC format: "1944")
      return parseInt(cleanDuration);
    } else if (/^\d{1,2}:\d{2}$/.test(cleanDuration)) {
      // MM:SS format (Democracy Now: "59:00")
      const [minutes, seconds] = cleanDuration.split(':').map(n => parseInt(n));
      return (minutes * 60) + seconds;
    } else if (/^\d{1,2}:\d{2}:\d{2}$/.test(cleanDuration)) {
      // HH:MM:SS format (CBC: "00:10:08")
      const [hours, minutes, seconds] = cleanDuration.split(':').map(n => parseInt(n));
      return (hours * 3600) + (minutes * 60) + seconds;
    }
    
    // Return 0 if format not recognized
    return 0;
  }

  function formatFileSize(bytes) {
    if (!bytes || bytes <= 0) return "";
    
    const mb = bytes / (1024 * 1024);
    if (mb >= 1000) {
      return (mb / 1024).toFixed(1) + " GB";
    } else if (mb >= 1) {
      return mb.toFixed(1) + " MB";
    } else {
      return (bytes / 1024).toFixed(0) + " KB";
    }
  }

  function firstItemFromRSS(xmlText){
    const doc = new DOMParser().parseFromString(xmlText, "application/xml");
    if (doc.querySelector("parsererror")) throw new Error("Invalid XML or blocked by CORS");

    // RSS 2.0
    let item = doc.querySelector("channel > item");
    // Atom
    if (!item) item = doc.querySelector("entry");
    if (!item) throw new Error("No items in feed");

    const title = (item.querySelector("title")?.textContent || "").trim();
    const pubRaw = (item.querySelector("pubDate, updated")?.textContent || "").trim();
    const pubDate = parsePubDate(pubRaw);

    // Extract episode metadata
    const description = (item.querySelector("description")?.textContent || 
                        item.querySelector("itunes\\:summary")?.textContent || 
                        item.querySelector("summary")?.textContent || "").trim();
    
    const duration = (item.querySelector("itunes\\:duration")?.textContent || "").trim();
    const author = (item.querySelector("itunes\\:author")?.textContent || 
                   item.querySelector("author")?.textContent || "").trim();

    // Extract image - try multiple sources
    let imageUrl = null;
    
    // Try episode-specific image first
    imageUrl = item.querySelector("itunes\\:image")?.getAttribute("href");
    if (!imageUrl) imageUrl = item.querySelector("media\\:thumbnail")?.getAttribute("url");
    if (!imageUrl) imageUrl = item.querySelector("image url")?.textContent?.trim();
    
    // Fall back to podcast/channel image
    if (!imageUrl) {
      const channel = doc.querySelector("channel");
      if (channel) {
        imageUrl = channel.querySelector("itunes\\:image")?.getAttribute("href");
        if (!imageUrl) imageUrl = channel.querySelector("image url")?.textContent?.trim();
        if (!imageUrl) {
          const img = channel.querySelector("image");
          if (img) imageUrl = img.querySelector("url")?.textContent?.trim();
        }
      }
    }

    // Prefer <enclosure url="...">
    let audioUrl = item.querySelector("enclosure[url]")?.getAttribute("url");
    let fileSize = null;
    
    // Extract file size from enclosure element (in bytes)
    const enclosure = item.querySelector("enclosure[url]");
    if (enclosure) {
      const lengthAttr = enclosure.getAttribute("length");
      if (lengthAttr && /^\d+$/.test(lengthAttr)) {
        fileSize = parseInt(lengthAttr);
      }
    }

    // media:content fallback
    if (!audioUrl){
      const m = item.querySelector("media\\:content[url], content[url]");
      if (m) audioUrl = m.getAttribute("url");
    }

    // CBC contentLink fallback (special case for CBC feeds)
    if (!audioUrl){
      const contentLink = item.querySelector("contentLink")?.textContent?.trim();
      if (contentLink && /\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(contentLink)) {
        audioUrl = contentLink;
      }
    }

    // GUID or link fallback if it looks like audio
    if (!audioUrl){
      const guid = item.querySelector("guid")?.textContent?.trim();
      const link = item.querySelector("link")?.textContent?.trim() || item.querySelector("link[href]")?.getAttribute("href");
      const pick = [guid, link].find(u => typeof u === "string" && /\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(u));
      if (pick) audioUrl = pick;
    }

    // PODCASTS ONLY: Reject items without audio content
    if (!audioUrl || !/\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(audioUrl)) {
      throw new Error("No audio content found - this appears to be an article feed, not a podcast");
    }

    // Extract unique identifiers for deduplication
    const guid = item.querySelector("guid")?.textContent?.trim();
    const link = item.querySelector("link")?.textContent?.trim() || item.querySelector("link[href]")?.getAttribute("href");
    
    // Determine best unique identifier (priority: GUID > audioUrl > link)
    const uniqueId = guid || audioUrl || link || title;

    return { title, pubDate, audioUrl, imageUrl, description, duration, author, uniqueId, fileSize };
  }

  function renderCard({label, title, pubDate, audioUrl, imageUrl, description, duration, author, uniqueId, fileSize}){
    // Check for duplicates using unique identifier
    if (uniqueId && seenEpisodes.has(uniqueId)) {
      duplicatesSkipped++;
      console.log(`üö´ Duplicate #${duplicatesSkipped}: "${title}" from ${label} (ID: ${uniqueId})`);
      return null; // Skip rendering this card
    }
    
    // Mark this episode as seen
    if (uniqueId) {
      seenEpisodes.add(uniqueId);
      console.log(`‚úÖ Episode added: "${title.substring(0, 50)}..." from ${label} (UniqueID: ${uniqueId.substring(0, 30)}...)`);
    }
    
    const when = hoursAgoIfToday(pubDate);
    const el = document.createElement("div");
    el.className = "card";
    
    // Store raw timestamp for sorting (crucial for news ordering!)
    if (pubDate) {
      el.setAttribute('data-pubdate', pubDate.getTime());
    }
    
    // Generate estimated duration for feeds that don't provide explicit duration
    let displayDuration = duration;
    if (!duration && label) {
      // Provide typical durations based on feed type
      const typicalDurations = {
        'NPR News Now': '5:00',
        'BBC Global News Podcast': '30:00',
        'BBC World Service Newshour': '50:00',
        'ABC (Australia) AM': '30:00',
        'Al Jazeera Updates': '15:00',
        'Democracy Now!': '60:00',
        'PBS NewsHour Audio': '45:00',
        'AP News Minute': '2:00',
        'CNN 5 Things': '8:00',
        'RFI Afrique Matin': '15:00',
        'France Info Journal': '20:00'
      };
      
      if (typicalDurations[label]) {
        displayDuration = `~${typicalDurations[label]}`;
      }
    }
    
    // Store duration in seconds for filtering (use displayDuration which includes estimates)
    const durationInSeconds = parseDurationToSeconds(displayDuration);
    el.setAttribute('data-duration-seconds', durationInSeconds);
    
    // Debug: Log duration parsing for troubleshooting
    if (durationInSeconds > 0) {
      console.log(`üìä Duration: "${label}" - Original: "${duration}" ‚Üí Display: "${displayDuration}" ‚Üí ${durationInSeconds}s (${(durationInSeconds/60).toFixed(1)} min)`);
    } else if (fileSize) {
      console.log(`üìÅ File Size: "${label}" - ${fileSize} bytes (${formatFileSize(fileSize)})`);
    }
    
    // Generate unique ID for this card
    const cardId = 'card-' + Math.random().toString(36).substr(2, 9);
    
    // Clean up description (remove HTML tags and extra whitespace)
    const cleanDescription = description ? description.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim() : '';
    
    // Hide summaries for feeds that don't have meaningful episode descriptions
    const feedsWithoutUsefulSummaries = ['NPR News Now', 'ABC (Australia) AM', 'Al Jazeera Updates'];
    const shouldShowSummary = !feedsWithoutUsefulSummaries.includes(label);
    const hasDescription = cleanDescription && cleanDescription.length > 50 && shouldShowSummary;
    
    el.innerHTML = 
      '<div class="source">' + esc(label) + '</div>' +
      '<div class="card-content">' +
        (imageUrl ? '<img class="podcast-image" src="' + esc(imageUrl) + '" alt="Podcast image" onerror="this.style.display=\'none\'">' : '') +
        '<div class="card-info">' +
          '<div class="title">' + (esc(title) || "(untitled episode)") + '</div>' +
          '<div class="row">' +
            '<div class="meta">' + 
              (when ? esc(when) : "") + 
              ((when && (displayDuration || fileSize)) ? ' ‚Ä¢ ' : '') +
              (displayDuration ? '<span class="duration">‚è±Ô∏è ' + esc(formatDuration(displayDuration)) + '</span>' : 
               (fileSize ? '<span class="duration">üìÅ ' + esc(formatFileSize(fileSize)) + '</span>' : '')) +
            '</div>' +
            '<button class="btn play-btn" type="button">Play</button>' +
          '</div>' +
          (hasDescription ? 
            '<div class="episode-summary">' +
              '<button class="summary-toggle" type="button">üìñ Show Details</button>' +
              '<div class="summary-content">' +
                '<div>' + esc(cleanDescription.substring(0, 500)) + (cleanDescription.length > 500 ? '...' : '') + '</div>' +
                '<div class="summary-meta">' +
                  (author ? '<span>üë§ ' + esc(author) + '</span>' : '') +
                '</div>' +
              '</div>' +
            '</div>' : '') +
        '</div>' +
      '</div>' +
      '<audio preload="none" controls src="' + esc(audioUrl) + '" class="global-audio" id="audio-' + cardId + '"></audio>' +
      '<div class="skip-controls">' +
        '<button class="skip-btn skip-back" type="button" aria-label="Skip back 30 seconds">‚è™ -30s</button>' +
        '<button class="skip-btn skip-forward" type="button" aria-label="Skip forward 30 seconds">‚è© +30s</button>' +
      '</div>';
    
    const btn = el.querySelector(".play-btn");
    const audio = el.querySelector("audio");
    const summaryToggle = el.querySelector(".summary-toggle");
    const summaryContent = el.querySelector(".summary-content");
    
    // Play button functionality
    btn.addEventListener("click", function() { 
      // Pause all other audio elements
      document.querySelectorAll('audio').forEach(a => {
        if (a !== audio) a.pause();
      });
      
      audio.play(); 
      btn.disabled = true; 
      btn.textContent = "Playing";
      
      // Apply global speed setting
      const globalSpeed = document.getElementById('global-speed').value;
      audio.playbackRate = parseFloat(globalSpeed);
    });
    
    // Reset button when audio ends or pauses
    audio.addEventListener("ended", function() {
      btn.disabled = false;
      btn.textContent = "Play";
    });
    
    audio.addEventListener("pause", function() {
      btn.disabled = false;
      btn.textContent = "Play";
    });
    
    // Skip controls functionality
    const skipBackBtn = el.querySelector(".skip-back");
    const skipForwardBtn = el.querySelector(".skip-forward");
    
    if (skipBackBtn) {
      skipBackBtn.addEventListener("click", function() {
        if (audio.duration && audio.currentTime) {
          audio.currentTime = Math.max(0, audio.currentTime - 30);
          console.log(`‚è™ Skipped back 30s to ${Math.round(audio.currentTime)}s`);
        }
      });
    }
    
    if (skipForwardBtn) {
      skipForwardBtn.addEventListener("click", function() {
        if (audio.duration) {
          audio.currentTime = Math.min(audio.duration, audio.currentTime + 30);
          console.log(`‚è© Skipped forward 30s to ${Math.round(audio.currentTime)}s`);
        }
      });
    }
    
    // Update skip button states based on audio progress
    audio.addEventListener("loadedmetadata", function() {
      skipBackBtn.disabled = false;
      skipForwardBtn.disabled = false;
    });
    
    audio.addEventListener("timeupdate", function() {
      // Disable skip back if at beginning
      skipBackBtn.disabled = audio.currentTime < 5;
      // Disable skip forward if near end
      skipForwardBtn.disabled = audio.duration && (audio.currentTime > audio.duration - 5);
    });

    // Summary toggle functionality
    if (summaryToggle && summaryContent) {
      summaryToggle.addEventListener("click", function() {
        const isExpanded = summaryContent.classList.contains('expanded');
        summaryContent.classList.toggle('expanded');
        summaryToggle.textContent = isExpanded ? 'üìñ Show Details' : 'üìñ Hide Details';
      });
    }
    
    return el;
  }

  function noteError(label, err){
    console.error("Failed to load " + label + ":", err);
    const p = document.createElement("p");
    p.className = "error";
    p.textContent = "Failed to load " + label + ": " + (err.message || err);
    errEl.appendChild(p);
  }

  function debugLog(message, data) {
    // Only log important events to reduce console spam
    if (message.includes('‚úÖ') || message.includes('‚ùå') || message.includes('Progressive loading')) {
      console.log("üéôÔ∏è " + message, data || '');
    }
  }

  function infoLog(message) {
    console.log("üì° " + message);
  }

  async function fetchText(url){
    debugLog("Attempting to fetch: " + url);
    
    // Try direct access first with browser-like headers
    try {
      debugLog("Trying direct fetch with browser headers");
      const r = await fetch(url, { 
        mode:"cors", 
        cache:"no-store",
        signal: AbortSignal.timeout(10000),
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
          'Accept': 'application/rss+xml, application/xml, text/xml, */*',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1'
        }
      });
      if (!r.ok) throw new Error("Direct HTTP " + r.status);
      const text = await r.text();
      debugLog("‚úÖ Successfully fetched directly, length: " + text.length);
      return text;
    } catch(directError) {
      infoLog("Using CORS proxy for " + url.split('/')[2]);
      
      // Try each proxy in sequence
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        try {
          const proxy = CORS_PROXIES[i];
          const proxyUrl = proxy + encodeURIComponent(url);
          debugLog("Trying proxy " + (i+1) + ": " + proxy);
          
          const r = await fetch(proxyUrl, { 
            cache:"no-store",
            signal: AbortSignal.timeout(8000),
            headers: {
              'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
              'Accept': 'application/rss+xml, application/xml, text/xml, */*',
              'Accept-Language': 'en-US,en;q=0.9',
              'Referer': 'https://www.google.com/'
            }
          });
          
          if (!r.ok) throw new Error("HTTP " + r.status);
          const text = await r.text();
          debugLog("‚úÖ Success with proxy " + (i+1) + ", length: " + text.length);
          return text;
        } catch(proxyError) {
          // Only log failures for the first attempt to reduce console spam
          if (i === 0) debugLog("‚ùå Proxy " + (i+1) + " failed: " + (proxyError.name === 'TimeoutError' ? 'timeout' : proxyError.message));
          continue;
        }
      }
      
      throw new Error("All methods failed. Direct: " + directError.message + ". All " + CORS_PROXIES.length + " proxies also failed.");
    }
  }

  async function loadSingleFeed(label, url){
    try {
      debugLog("Loading single feed: " + label);
      const xml = await fetchText(url);
      const info = firstItemFromRSS(xml);
      debugLog("Parsed feed item:", { title: info.title, pubDate: info.pubDate, hasAudio: !!info.audioUrl });
      const card = renderCard({ 
        label: label, 
        title: info.title, 
        pubDate: info.pubDate, 
        audioUrl: info.audioUrl, 
        imageUrl: info.imageUrl,
        description: info.description,
        duration: info.duration,
        author: info.author,
        uniqueId: info.uniqueId,
        fileSize: info.fileSize
      });
      debugLog("Successfully created card for: " + label);
      return card;
    } catch(e) {
      noteError(label, e);
      return null;
    }
  }

  // CRITICAL: Sort podcast cards by publication date (newest first) for latest news
  function sortCardsByDate(container) {
    const cards = Array.from(container.children);
    
    cards.sort((cardA, cardB) => {
      // Use stored timestamp for reliable sorting
      const timestampA = parseInt(cardA.getAttribute('data-pubdate')) || 0;
      const timestampB = parseInt(cardB.getAttribute('data-pubdate')) || 0;
      
      // Sort newest first (descending order) - CRITICAL for news relevance
      return timestampB - timestampA;
    });
    
    // Re-append cards in sorted order
    container.innerHTML = '';
    cards.forEach(card => container.appendChild(card));
    
    debugLog("‚úÖ Sorted " + cards.length + " cards by date (newest first)");
  }

  // Load individual CBC feeds as separate cards
  async function loadAndDisplayCbcFeed(cbcFeed) {
    try {
      debugLog("Loading CBC feed: " + cbcFeed.label);
      const card = await loadSingleFeed(cbcFeed.label, cbcFeed.url);
      if (card) {
        cardsEnglishEl.appendChild(card);
        
        // Add fade-in animation
        card.style.opacity = '0';
        setTimeout(() => {
          card.style.transition = 'opacity 0.3s ease';
          card.style.opacity = '1';
        }, 10);
        
        debugLog("‚úÖ Displayed: " + cbcFeed.label);
      }
    } catch(e) {
      console.warn("‚ö†Ô∏è Could not load " + cbcFeed.label + " (CORS/network issue)");
    }
  }

  // Progressive loading function that shows cards as they load
  async function loadAndDisplayFeed(label, url, isEnglish = true) {
    try {
      debugLog("Loading feed: " + label);
      const card = await loadSingleFeed(label, url);
      if (card) {
        const targetContainer = isEnglish ? cardsEnglishEl : cardsFrenchEl;
        targetContainer.appendChild(card);
        
        // Add fade-in animation to new card
        card.style.opacity = '0';
        setTimeout(() => {
          card.style.transition = 'opacity 0.3s ease';
          card.style.opacity = '1';
        }, 10);
        
        debugLog("‚úÖ Displayed: " + label);
      }
    } catch(e) {
      console.warn("‚ö†Ô∏è Could not load " + label + " (CORS/network issue)");
    }
  }



  (async function init(){
    debugLog("Starting progressive RSS feed loading...");
    
    // Show content area immediately (no waiting for all feeds)
    loadingEl.style.display = "none";
    contentEl.style.display = "block";
    contentEl.style.opacity = "1";
    
    let totalLoaded = 0;
    const totalFeeds = FEEDS.length + FRENCH_FEEDS.length + CBC_FEEDS.length;
    
    // Load feeds in parallel for speed, but display each as it completes
    const loadPromises = [];
    
    // Start loading English feeds (fast ones first: BBC, ABC, Al Jazeera)
    FEEDS.forEach(f => {
      loadPromises.push(loadAndDisplayFeed(f.label, f.url, true));
    });
    
    // Start loading each CBC feed individually
    CBC_FEEDS.forEach(cbcFeed => {
      loadPromises.push(loadAndDisplayCbcFeed(cbcFeed));
    });
    
    // Start loading French feeds
    FRENCH_FEEDS.forEach(f => {
      loadPromises.push(loadAndDisplayFeed(f.label, f.url, false));
    });
    
    // Wait for all feeds to complete (but they're already displayed as they load)
    await Promise.allSettled(loadPromises);
    
    // CRITICAL: Sort all cards by publication date (newest first) - this is essential for news!
    sortCardsByDate(cardsEnglishEl);
    if (FRENCH_FEEDS.length > 0) {
      sortCardsByDate(cardsFrenchEl);
    }
    
    // Cache English content for language switching
    const englishCards = Array.from(cardsEnglishEl.children);
    const englishContent = englishCards.map(card => card.outerHTML);
    localStorage.setItem('cachedEnglishCards', JSON.stringify({
      timestamp: Date.now(),
      content: englishContent
    }));
    
    // Final summary
    const englishCount = cardsEnglishEl.children.length;
    const frenchCount = cardsFrenchEl.children.length;
    const totalCards = englishCount + frenchCount;
    const errorCount = errEl.children.length;
    
    console.log("üéôÔ∏è Loaded " + totalCards + " podcast" + (totalCards === 1 ? "" : "s") + " successfully!");
    if (duplicatesSkipped > 0) {
      console.log("üö´ Prevented " + duplicatesSkipped + " duplicate episode" + (duplicatesSkipped === 1 ? "" : "s") + " from showing.");
    } else {
      console.log("‚úÖ No duplicate episodes detected.");
    }
    
    if (totalCards === 0) {
      const p = document.createElement("p");
      p.className = "error";
      p.textContent = "No podcast feeds could be loaded. Check the browser console for detailed error messages.";
      errEl.appendChild(p);
    }
  })();

  // UI Controls functionality
  const themeToggle = document.getElementById('theme-toggle');
  const languageToggle = document.getElementById('language-toggle');
  const refreshButton = document.getElementById('refresh-button');
  const englishSection = document.getElementById('english-section');
  const frenchSection = document.getElementById('french-section');

  // Theme toggle
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    themeToggle.textContent = isLight ? 'üåô Dark' : '‚òÄÔ∏è Light';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
  });

  // Load saved theme
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'light') {
    document.body.classList.add('light-theme');
    themeToggle.textContent = 'üåô Dark';
  }

  // Language toggle with three states: English ‚Üí French ‚Üí Both ‚Üí English
  let languageState = localStorage.getItem('languageState') || 'english';
  
  function updateLanguageDisplay() {
    switch(languageState) {
      case 'english':
        englishSection.style.display = 'block';
        frenchSection.style.display = 'none';
        languageToggle.textContent = 'üá´üá∑ Fran√ßais';
        break;
      case 'french':
        englishSection.style.display = 'none';
        frenchSection.style.display = 'block';
        languageToggle.textContent = 'üåç Both';
        break;
      case 'both':
        englishSection.style.display = 'block';
        frenchSection.style.display = 'block';
        languageToggle.textContent = 'üá¨üáß English';
        
        // Note: Cache restore disabled to prevent bypassing duplicate detection
        // Cards will reload fresh when switching back to ensure deduplication works
        console.log('üîÑ Fresh loading enabled (cache restore disabled for deduplication)');
        break;
    }
    localStorage.setItem('languageState', languageState);
  }

  languageToggle.addEventListener('click', () => {
    if (languageState === 'english') {
      languageState = 'french';
    } else if (languageState === 'french') {
      languageState = 'both';
    } else {
      languageState = 'english';
    }
    updateLanguageDisplay();
  });

  // Initialize language display
  updateLanguageDisplay();

  // Refresh button
  refreshButton.addEventListener('click', () => {
    location.reload();
  });

  // Global audio controls
  const globalSpeedSelect = document.getElementById('global-speed');
  const globalSleepSelect = document.getElementById('global-sleep');
  const globalSleepStatus = document.getElementById('global-sleep-status');
  const durationFilter = document.getElementById('duration-filter');
  
  let globalSleepTimer = null;
  let globalSleepInterval = null;
  let currentAudio = null;
  
  // Duration filtering function
  function filterCardsByDuration(filterValue) {
    const allCards = document.querySelectorAll('.card');
    let visibleCount = 0;
    
    console.log(`üîç Filtering by "${filterValue}". Found ${allCards.length} cards to check.`);
    
    allCards.forEach((card, index) => {
      const durationSeconds = parseInt(card.getAttribute('data-duration-seconds')) || 0;
      const durationMinutes = durationSeconds / 60;
      const cardTitle = card.querySelector('.title')?.textContent || 'Unknown';
      let shouldShow = true;
      
      // Debug: Log each card's duration data
      if (index < 5) { // Only log first 5 to avoid spam
        console.log(`Card ${index + 1}: "${cardTitle.substring(0, 30)}..." - ${durationSeconds}s (${durationMinutes.toFixed(1)} min)`);
      }
      
      switch(filterValue) {
        case 'short':
          shouldShow = durationMinutes > 0 && durationMinutes < 10;
          break;
        case 'medium':
          shouldShow = durationMinutes >= 10 && durationMinutes <= 30;
          break;
        case 'long':
          shouldShow = durationMinutes > 30;
          break;
        case 'all':
        default:
          shouldShow = true;
          break;
      }
      
      if (shouldShow) {
        card.style.display = '';
        visibleCount++;
      } else {
        card.style.display = 'none';
      }
    });
    
    console.log(`üîç Duration filter "${filterValue}": showing ${visibleCount} of ${allCards.length} podcasts`);
  }
  
  // Duration filter event listener
  durationFilter.addEventListener('change', () => {
    const filterValue = durationFilter.value;
    filterCardsByDuration(filterValue);
    localStorage.setItem('durationFilter', filterValue);
  });
  
  // Load saved duration filter
  const savedDurationFilter = localStorage.getItem('durationFilter');
  if (savedDurationFilter) {
    durationFilter.value = savedDurationFilter;
    // Apply filter after cards are loaded (use a small delay)
    setTimeout(() => filterCardsByDuration(savedDurationFilter), 1000);
  }
  
  // Global speed control
  globalSpeedSelect.addEventListener('change', () => {
    const speed = parseFloat(globalSpeedSelect.value);
    // Apply to currently playing audio
    document.querySelectorAll('audio').forEach(audio => {
      if (!audio.paused) {
        audio.playbackRate = speed;
      }
    });
  });
  
  // Global sleep timer functionality
  function clearGlobalSleepTimer() {
    if (globalSleepTimer) clearTimeout(globalSleepTimer);
    if (globalSleepInterval) clearInterval(globalSleepInterval);
    globalSleepTimer = null;
    globalSleepInterval = null;
    globalSleepStatus.textContent = "";
    // Reset volume for all audio elements
    document.querySelectorAll('audio').forEach(audio => {
      audio.volume = 1;
    });
  }
  
  function startGlobalSleepTimer(minutes) {
    clearGlobalSleepTimer();
    
    if (minutes === 0) return;
    
    const totalMs = minutes * 60 * 1000;
    const fadeStartMs = totalMs - (2 * 60 * 1000); // Start fading 2 minutes before end
    let remainingTime = minutes * 60; // seconds
    
    // Update countdown every second
    globalSleepInterval = setInterval(() => {
      remainingTime--;
      const mins = Math.floor(remainingTime / 60);
      const secs = remainingTime % 60;
      globalSleepStatus.textContent = `Sleep: ${mins}:${secs.toString().padStart(2, '0')}`;
      
      // Start volume fade in last 2 minutes
      const elapsed = (minutes * 60) - remainingTime;
      if (elapsed * 1000 >= fadeStartMs) {
        const fadeProgress = (elapsed * 1000 - fadeStartMs) / (2 * 60 * 1000);
        const volume = Math.max(0, 1 - fadeProgress);
        // Apply fade to all audio elements
        document.querySelectorAll('audio').forEach(audio => {
          if (!audio.paused) {
            audio.volume = volume;
          }
        });
      }
      
      if (remainingTime <= 0) {
        // Pause all audio
        document.querySelectorAll('audio').forEach(audio => {
          audio.pause();
        });
        clearGlobalSleepTimer();
      }
    }, 1000);
    
    globalSleepStatus.textContent = `Sleep: ${minutes}:00`;
  }
  
  globalSleepSelect.addEventListener('change', () => {
    const minutes = parseInt(globalSleepSelect.value);
    startGlobalSleepTimer(minutes);
  });

  // Track currently playing audio for sleep timer
  document.addEventListener('play', (e) => {
    if (e.target.tagName === 'AUDIO') {
      currentAudio = e.target;
      // Apply current global speed to newly playing audio
      const globalSpeed = parseFloat(globalSpeedSelect.value);
      e.target.playbackRate = globalSpeed;
    }
  }, true);

  // Global keyboard shortcuts for skip functionality
  document.addEventListener('keydown', (e) => {
    // Only work if an audio is currently playing and no input is focused
    if (currentAudio && !currentAudio.paused && !['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
      switch(e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          currentAudio.currentTime = Math.max(0, currentAudio.currentTime - 30);
          console.log(`‚è™ Keyboard skip back 30s to ${Math.round(currentAudio.currentTime)}s`);
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (currentAudio.duration) {
            currentAudio.currentTime = Math.min(currentAudio.duration, currentAudio.currentTime + 30);
            console.log(`‚è© Keyboard skip forward 30s to ${Math.round(currentAudio.currentTime)}s`);
          }
          break;
        case ' ':
          e.preventDefault();
          if (currentAudio.paused) {
            currentAudio.play();
          } else {
            currentAudio.pause();
          }
          break;
      }
    }
  });
})();
</script>
</body>
</html>