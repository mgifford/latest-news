<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Latest News Podcasts: CBC, BBC, Al Jazeera, ABC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0c0d; --card:#15171a; --text:#e9eef2; --muted:#aab4be; --accent:#79b8ff; }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:1rem 1.25rem;border-bottom:1px solid #222}
    h1{margin:0;font-size:1.1rem;letter-spacing:.3px}
    .wrap{max-width:920px;margin:0 auto;padding:1rem}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:1rem}
    .card{background:var(--card);border:1px solid #222;border-radius:14px;padding:1rem;display:flex;flex-direction:column;gap:.75rem}
    .source{font-size:.8rem;color:var(--muted)}
    .title{font-weight:600;line-height:1.2}
    .meta{font-size:.85rem;color:var(--muted)}
    .row{display:flex;justify-content:space-between;gap:.5rem;align-items:center}
    .btn{appearance:none;border:1px solid #2a2f36;background:#0e1116;color:var(--text);padding:.45rem .7rem;border-radius:8px;font-size:.9rem;cursor:pointer}
    .btn:hover{border-color:#39424d}
    audio{width:100%}
    .error{color:#ff9aa2;font-size:.9rem}
    footer{color:var(--muted);font-size:.8rem;text-align:center;margin:1.5rem 0}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    
    /* UI Controls */
    .controls{display:flex;gap:0.5rem;margin-bottom:1rem;flex-wrap:wrap}
    .control-btn{padding:0.5rem 1rem;border:1px solid #333;background:#1a1a1a;color:var(--text);border-radius:6px;cursor:pointer;font-size:0.9rem}
    .control-btn:hover{background:#2a2a2a;border-color:#444}
    
    /* Language sections */
    #english-section, #french-section{margin-bottom:2rem}
    #french-section{display:none}
    .section-title{font-size:1.2rem;margin-bottom:1rem;color:var(--accent);border-bottom:1px solid #333;padding-bottom:0.5rem}
    
    /* Light theme */
    body.light-theme{--bg:#ffffff; --card:#f8f9fa; --text:#24292e; --muted:#586069; --accent:#0366d6}
    body.light-theme .control-btn{background:#f6f8fa;border-color:#d0d7de;color:var(--text)}
    body.light-theme .control-btn:hover{background:#f3f4f6;border-color:#afb8c1}
    body.light-theme .section-title{border-color:#d0d7de}

    /* Loading animation */
    .loading{text-align:center;padding:2rem}
    .spinner{display:inline-block;width:40px;height:40px;border:4px solid #333;border-radius:50%;border-top-color:var(--accent);animation:spin 1s ease-in-out infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    
    /* Fade animations */
    .fade-out{opacity:0;transition:opacity 0.5s ease}
    .fade-in{opacity:1;transition:opacity 0.5s ease}
    #content{opacity:0}
  </style>
</head>
<body>
  <header><h1>üéôÔ∏è Latest News Podcasts</h1></header>
  <div class="wrap">
    <div class="controls">
      <button id="theme-toggle" class="control-btn">üåô Dark</button>
      <button id="language-toggle" class="control-btn">üá´üá∑ Fran√ßais</button>
      <button id="refresh-button" class="control-btn">üîÑ Refresh</button>
    </div>
    
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <p>Loading latest podcasts...</p>
    </div>
    
    <div id="content" style="display:none">
      <div id="english-section">
        <h2 class="section-title">üá¨üáß English Podcasts</h2>
        <div id="cards-english" class="grid" aria-live="polite"></div>
      </div>
      
      <div id="french-section">
        <h2 class="section-title">üá´üá∑ Podcasts Fran√ßais</h2>
        <div id="cards-french" class="grid" aria-live="polite"></div>
      </div>
      
      <div id="errors"></div>
      <footer>Feeds load fresh on page open. Times shown in your local timezone.</footer>
    </div>
  </div>

<script>
(function(){
  console.log("RSS script starting...");
  
  // Multiple CORS proxy options - try them in order
  const CORS_PROXIES = [
    "https://api.codetabs.com/v1/proxy?quest=",
    "https://cors-anywhere.herokuapp.com/",
    "https://api.allorigins.win/raw?url="
  ];

  // CBC podcast feeds (grouped - pick newest episode, ordered by your tested working URL first)
  const CBC_FEEDS = [
    "https://www.cbc.ca/podcasting/includes/wr.xml",           // World Report (your working URL!)
    "https://www.cbc.ca/podcasting/includes/w6.xml",           // Your World Tonight
    "https://www.cbc.ca/podcasting/includes/hourlynews.xml",   // The World This Hour
    "https://www.cbc.ca/podcasting/includes/thehouse.xml"      // The House
  ];

  // English podcast feeds (ordered by reliability - fastest first)
  const FEEDS = [
    { key:"bbc-podcast",  label:"BBC Global News Podcast",     url:"https://podcasts.files.bbci.co.uk/p02nq0gn.rss" },
    { key:"abc",          label:"ABC (Australia) AM",          url:"https://www.abc.net.au/feeds/8486620/podcast.xml" },
    { key:"aje",          label:"Al Jazeera Updates",          url:"https://omnycontent.com/d/playlist/9c074afa-3313-47e8-b802-a9f900789975/63048eda-2427-408a-b47c-ad5001293fca/6677d422-fd43-4aaa-be74-ad5001293fd8/podcast.rss" },
  ];

  // French podcast feeds
  const FRENCH_FEEDS = [
    { key:"rfi-francais", label:"RFI - Journal en fran√ßais facile", url:"https://rss.rfi.fr/liveaudio/rfi_francais_facile/rss.xml" },
    { key:"france24-fr", label:"France 24 - Actualit√©s", url:"https://www.france24.com/fr/actualit√©s/rss" }
  ];

  const cardsEnglishEl = document.getElementById("cards-english");
  const cardsFrenchEl = document.getElementById("cards-french");
  const errEl = document.getElementById("errors");
  const loadingEl = document.getElementById("loading");
  const contentEl = document.getElementById("content");

  function esc(s){ 
    return s == null ? "" : (""+s).replace(/[&<>"']/g, function(c) {
      const escMap = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"};
      return escMap[c];
    }); 
  }

  function parsePubDate(d){
    // Try native Date; many podcast feeds are RFC822/RFC1123 or ISO8601
    const dt = new Date(d);
    return isNaN(dt) ? null : dt;
  }

  function hoursAgoIfToday(dt){
    if (!dt) return "";
    const now = new Date();
    if (dt.toDateString() === now.toDateString()){
      const hrs = Math.max(0, Math.round((now - dt)/36e5));
      return hrs + " hour" + (hrs===1?"":"s") + " ago";
    }
    return dt.toLocaleString(undefined, { dateStyle:"medium", timeStyle:"short" });
  }

  function firstItemFromRSS(xmlText){
    const doc = new DOMParser().parseFromString(xmlText, "application/xml");
    if (doc.querySelector("parsererror")) throw new Error("Invalid XML or blocked by CORS");

    // RSS 2.0
    let item = doc.querySelector("channel > item");
    // Atom
    if (!item) item = doc.querySelector("entry");
    if (!item) throw new Error("No items in feed");

    const title = (item.querySelector("title")?.textContent || "").trim();
    const pubRaw = (item.querySelector("pubDate, updated")?.textContent || "").trim();
    const pubDate = parsePubDate(pubRaw);

    // Prefer <enclosure url="...">
    let audioUrl = item.querySelector("enclosure[url]")?.getAttribute("url");

    // media:content fallback
    if (!audioUrl){
      const m = item.querySelector("media\\:content[url], content[url]");
      if (m) audioUrl = m.getAttribute("url");
    }

    // CBC contentLink fallback (special case for CBC feeds)
    if (!audioUrl){
      const contentLink = item.querySelector("contentLink")?.textContent?.trim();
      if (contentLink && /\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(contentLink)) {
        audioUrl = contentLink;
      }
    }

    // GUID or link fallback if it looks like audio
    if (!audioUrl){
      const guid = item.querySelector("guid")?.textContent?.trim();
      const link = item.querySelector("link")?.textContent?.trim() || item.querySelector("link[href]")?.getAttribute("href");
      const pick = [guid, link].find(u => typeof u === "string" && /\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(u));
      if (pick) audioUrl = pick;
    }

    // PODCASTS ONLY: Reject items without audio content
    if (!audioUrl || !/\.(mp3|m4a|aac|ogg|wav)(\?|$)/i.test(audioUrl)) {
      throw new Error("No audio content found - this appears to be an article feed, not a podcast");
    }

    return { title, pubDate, audioUrl };
  }

  function renderCard({label, title, pubDate, audioUrl}){
    const when = hoursAgoIfToday(pubDate);
    const el = document.createElement("div");
    el.className = "card";
    el.innerHTML = 
      '<div class="source">' + esc(label) + '</div>' +
      '<div class="title">' + (esc(title) || "(untitled episode)") + '</div>' +
      '<div class="row">' +
        '<div class="meta">' + (when ? esc(when) : "") + '</div>' +
        '<button class="btn" type="button">Play</button>' +
      '</div>' +
      '<audio preload="none" controls src="' + esc(audioUrl) + '"></audio>';
    
    const btn = el.querySelector("button");
    const audio = el.querySelector("audio");
    btn.addEventListener("click", function() { 
      audio.play(); 
      btn.disabled = true; 
      btn.textContent = "Playing"; 
    });
    return el;
  }

  function noteError(label, err){
    console.error("Failed to load " + label + ":", err);
    const p = document.createElement("p");
    p.className = "error";
    p.textContent = "Failed to load " + label + ": " + (err.message || err);
    errEl.appendChild(p);
  }

  function debugLog(message, data) {
    console.log("[RSS Debug] " + message, data || '');
  }

  async function fetchText(url){
    debugLog("Attempting to fetch: " + url);
    
    // Try direct access first (many RSS feeds support CORS now)
    try {
      debugLog("Trying direct fetch");
      const r = await fetch(url, { 
        mode:"cors", 
        cache:"no-store",
        signal: AbortSignal.timeout(10000) // 10 second timeout
      });
      if (!r.ok) throw new Error("Direct HTTP " + r.status);
      const text = await r.text();
      debugLog("Successfully fetched directly, length: " + text.length);
      return text;
    } catch(directError) {
      debugLog("Direct fetch failed (" + directError.message + "), trying CORS proxies");
      
      // Try each proxy in sequence
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        try {
          const proxy = CORS_PROXIES[i];
          const proxyUrl = proxy + encodeURIComponent(url);
          debugLog("Trying proxy " + (i+1) + ": " + proxy);
          
          const r = await fetch(proxyUrl, { 
            cache:"no-store",
            signal: AbortSignal.timeout(15000) // 15 second timeout
          });
          
          if (!r.ok) throw new Error("HTTP " + r.status);
          const text = await r.text();
          debugLog("Success with proxy " + (i+1) + ", length: " + text.length);
          return text;
        } catch(proxyError) {
          debugLog("Proxy " + (i+1) + " failed: " + proxyError.message);
          continue;
        }
      }
      
      throw new Error("All methods failed. Direct: " + directError.message + ". All " + CORS_PROXIES.length + " proxies also failed.");
    }
  }

  async function loadSingleFeed(label, url){
    try {
      debugLog("Loading single feed: " + label);
      const xml = await fetchText(url);
      const info = firstItemFromRSS(xml);
      debugLog("Parsed feed item:", { title: info.title, pubDate: info.pubDate, hasAudio: !!info.audioUrl });
      const card = renderCard({ label: label, title: info.title, pubDate: info.pubDate, audioUrl: info.audioUrl });
      debugLog("Successfully created card for: " + label);
      return card;
    } catch(e) {
      noteError(label, e);
      return null;
    }
  }

  async function loadCbcGroup(){
    try{
      debugLog("Loading CBC feeds: " + CBC_FEEDS.length + " feeds");
      const xmls = await Promise.allSettled(CBC_FEEDS.map(u => fetchText(u)));
      const items = [];
      
      for (let i = 0; i < xmls.length; i++){
        const r = xmls[i];
        const url = CBC_FEEDS[i];
        if (r.status === "fulfilled"){
          try { 
            const item = firstItemFromRSS(r.value);
            debugLog("Parsed CBC feed " + (i+1) + ":", { url: url, title: item.title, pubDate: item.pubDate });
            items.push(item);
          }
          catch(e) { 
            debugLog("Failed to parse CBC feed " + (i+1) + " (" + url + "):", e.message);
          }
        } else {
          debugLog("Failed to fetch CBC feed " + (i+1) + " (" + url + "):", r.reason?.message || r.reason);
        }
      }
      
      if (items.length === 0) throw new Error("No CBC items parsed from " + CBC_FEEDS.length + " feeds");

      // Pick newest by pubDate; if missing, push to end
      items.sort(function(a,b) {
        const ta = a.pubDate ? a.pubDate.getTime() : 0;
        const tb = b.pubDate ? b.pubDate.getTime() : 0;
        return tb - ta;
      });
      const latest = items[0];
      debugLog("Selected latest CBC item:", { title: latest.title, pubDate: latest.pubDate });
      const card = renderCard({ label: "CBC (latest across multiple shows)", title: latest.title, pubDate: latest.pubDate, audioUrl: latest.audioUrl });
      return card;
    } catch(e){
      noteError("CBC", e);
      return null;
    }
  }

  (async function init(){
    debugLog("Starting RSS feed loading...");
    
    const englishCards = [];
    const frenchCards = [];
    
    // Load English feeds (individual + CBC group)
    for (const f of FEEDS){
      try {
        const card = await loadSingleFeed(f.label, f.url);
        if (card) englishCards.push(card);
      } catch(e) {
        debugLog("Failed to load English feed " + f.label + ":", e.message);
      }
    }
    
    // Load CBC group for English
    try {
      const card = await loadCbcGroup();
      if (card) englishCards.push(card);
    } catch(e) {
      debugLog("Failed to load CBC group:", e.message);
    }
    
    // Load French feeds
    for (const f of FRENCH_FEEDS){
      try {
        const card = await loadSingleFeed(f.label, f.url);
        if (card) frenchCards.push(card);
      } catch(e) {
        debugLog("Failed to load French feed " + f.label + ":", e.message);
      }
    }
    
    // Sort by date (newest first)
    const sortByDate = (cards) => cards.sort((a, b) => {
      const dateA = a.querySelector('.meta')?.textContent || '';
      const dateB = b.querySelector('.meta')?.textContent || '';
      
      // Prioritize "hours ago" items
      const hoursA = dateA.includes('hour');
      const hoursB = dateB.includes('hour');
      
      if (hoursA && !hoursB) return -1;
      if (!hoursA && hoursB) return 1;
      
      return dateB.localeCompare(dateA);
    });
    
    // Re-append sorted cards
    sortByDate(englishCards).forEach(card => cardsEnglishEl.appendChild(card));
    sortByDate(frenchCards).forEach(card => cardsFrenchEl.appendChild(card));

    // Cache English content for 'Both' mode restoration
    const englishContent = englishCards.map(card => card.outerHTML);
    localStorage.setItem('cachedEnglishCards', JSON.stringify({
      timestamp: Date.now(),
      content: englishContent
    }));
    
    // Hide loading, show results with fade effect
    loadingEl.classList.add("fade-out");
    setTimeout(function() {
      loadingEl.style.display = "none";
      contentEl.style.display = "block";
      contentEl.classList.add("fade-in");
    }, 500);
    
    // Show summary
    const englishCount = cardsEnglishEl.children.length;
    const frenchCount = cardsFrenchEl.children.length;
    const totalCards = englishCount + frenchCount;
    const errorCount = errEl.children.length;
    console.log("Feed loading complete: " + totalCards + " podcasts loaded (" + englishCount + " English, " + frenchCount + " French), " + errorCount + " errors");
    
    if (totalCards === 0) {
      const p = document.createElement("p");
      p.className = "error";
      p.textContent = "No podcast feeds could be loaded. Check the browser console for detailed error messages.";
      errEl.appendChild(p);
    }
  })();

  // UI Controls functionality
  const themeToggle = document.getElementById('theme-toggle');
  const languageToggle = document.getElementById('language-toggle');
  const refreshButton = document.getElementById('refresh-button');
  const englishSection = document.getElementById('english-section');
  const frenchSection = document.getElementById('french-section');

  // Theme toggle
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    themeToggle.textContent = isLight ? 'üåô Dark' : '‚òÄÔ∏è Light';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
  });

  // Load saved theme
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'light') {
    document.body.classList.add('light-theme');
    themeToggle.textContent = 'üåô Dark';
  }

  // Language toggle with three states: English ‚Üí French ‚Üí Both ‚Üí English
  let languageState = localStorage.getItem('languageState') || 'english';
  
  function updateLanguageDisplay() {
    switch(languageState) {
      case 'english':
        englishSection.style.display = 'block';
        frenchSection.style.display = 'none';
        languageToggle.textContent = 'üá´üá∑ Fran√ßais';
        break;
      case 'french':
        englishSection.style.display = 'none';
        frenchSection.style.display = 'block';
        languageToggle.textContent = 'üåç Both';
        break;
      case 'both':
        englishSection.style.display = 'block';
        frenchSection.style.display = 'block';
        languageToggle.textContent = 'üá¨üáß English';
        
        // Restore English cards from cache if available and English section is empty
        if (cardsEnglishEl.children.length === 0) {
          const cached = localStorage.getItem('cachedEnglishCards');
          if (cached) {
            try {
              const { content, timestamp } = JSON.parse(cached);
              // Only use cache if it's less than 1 hour old
              if (Date.now() - timestamp < 3600000) {
                content.forEach(cardHtml => {
                  cardsEnglishEl.innerHTML += cardHtml;
                });
              }
            } catch(e) {
              console.warn('Failed to restore cached English cards:', e);
            }
          }
        }
        break;
    }
    localStorage.setItem('languageState', languageState);
  }

  languageToggle.addEventListener('click', () => {
    if (languageState === 'english') {
      languageState = 'french';
    } else if (languageState === 'french') {
      languageState = 'both';
    } else {
      languageState = 'english';
    }
    updateLanguageDisplay();
  });

  // Initialize language display
  updateLanguageDisplay();

  // Refresh button
  refreshButton.addEventListener('click', () => {
    location.reload();
  });
})();
</script>
</body>
</html>
